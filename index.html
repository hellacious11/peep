<html>
  <head>
    <title>Mystery Box</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
      rel="stylesheet"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/web3@1.2.11/dist/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/big.js/5.2.2/big.min.js"></script>

    <style>
      @font-face {
        font-family: "Quin";
        src: url("./fonts/Quinquefive-ALoRM.ttf") format("truetype");
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: -1;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        text-align: center;
        /* text-transform: uppercase; */
        color: #fff;
        height: 100vh;
        margin: 0;
        padding: 10px;
        line-height: 1.5;
        font-family: "Roboto", sans-serif;
        background: #101711;
        font-family: Arial, sans-serif;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        color: #ff8a9d;
        font-family: "Quin", sans-serif;
      }

      p {
        font-family: "Roboto", sans-serif;
        overflow: hidden;
      }
      img {
        width: 300px;
        height: auto;
        margin-top: 20px;
      }

      a,
      a:visited {
        color: #ff8a9d;
      }

      .bg {
        background-image: url("./bg.avif");
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-size: cover;
        z-index: -1;
        opacity: 0.1;
      }

      .content {
        max-width: 500px;
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        margin: 1px;
        width: 90%;
        border: 2px dotted #ff8a9d;
        padding: 20px;
      }

      h1 {
        font-size: 1.5em;
      }
      .logo {
        border-radius: 100%;
      }

      .hint {
        opacity: 0.5;
      }

      .content-2 {
        max-width: 540px;
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        width: 100%;
        border: 2px dotted #ff8a9d;
      }

      input {
        text-align: center;
        background: rgba(0, 0, 0, 0.5);
        width: 100%;
        background-color: rgba(255, 255, 255, 0.1);
        color: #fff;
        outline: none;
        font-size: 18px;
        border: 0;
        padding: 20px 0;
      }

      .btn {
        display: block;
        padding: 20px 0;
        width: 100%;
        color: #fff;
        cursor: pointer;
        background-color: #ff8a9d;
        font-family: "Quin", sans-serif;
        border: 0;
      }

      #conn-as,
      #Bal {
        margin: 30px 0;
        opacity: 0.5;
      }

      .hide {
        display: none;
      }
    </style>
  </head>
  <body>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-80QVYHHVBV"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-689BGZP7S2");
    </script>

    <!-- <div class="bg"></div> -->
    <div class="content">
      <h1>Mystery Box</h1>
      <p class="hint">
        <!-- <b> -->
        Whoever solves the riddle will receive a bounty worth
        <span id="reward-amt">-</span> ETH. The riddle is embeded on-chain. You
        will need to burn 1000 MYSTERY to participate.
        <!-- </b> -->
      </p>

      <p>
        "I speak without a mouth and hear without ears. I have no body, but I
        come alive with the wind. What am I?"
      </p>

      <!-- <br /> -->
      <p>
        CA:
        <a
          href="https://etherscan.io/token/0x631EF9d9b7c258A27BFf064b3065033dF163Df74"
          target="_blank"
        >
          0x631EF9d9b7c258A27BFf064b3065033dF163Df74
        </a>
      </p>
      <p>
        Telegram:
        <a href="https://t.me/themysteryeth" target="_blank">
          @themysteryeth
        </a>
      </p>
      <p>
        Click here to
        <a
          href="https://app.uniswap.org/#/swap?outputCurrency=0x631EF9d9b7c258A27BFf064b3065033dF163Df74&exactAmount=1000&exactField=output"
          target="_blank"
        >
          BUY 1000 MYSTERY
        </a>
      </p>
    </div>

    <div></div>
    <h2>PRIZE: <span id="reward-amt-2">-</span> ETH</h2>

    <div class="content-2">
      <input placeholder="What is the answer?" id="answer" />

      <button onclick="connectToWallet()" class="btn" id="connect">
        Connect Wallet
      </button>
      <button onclick="submitAnswer()" class="btn hide" id="submit">
        Submit the Answer
      </button>
    </div>
    <div id="conn-as" class="hide">
      connected as <span id="who"></span>
      <br />
      You have <span id="bal-amt">0</span> MYSTERY. Buy more from
      <a
        href="https://app.uniswap.org/#/swap?outputCurrency=0x631EF9d9b7c258A27BFf064b3065033dF163Df74&exactAmount=1000&exactField=output"
        target="_blank"
      >
        Uniswap
      </a>
    </div>

    <canvas id="c"></canvas>

    <script>
      function updateETHRewardText(eth) {
        document.getElementById("reward-amt").innerHTML = eth;
        document.getElementById("reward-amt-2").innerHTML = eth;
      }

      function updateBalText(eth) {
        document.getElementById("bal-amt").innerHTML = eth;
      }
    </script>

    <script>
      const tokenAddress = "0x631EF9d9b7c258A27BFf064b3065033dF163Df74";
      const wethAddress = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
      const lpAddress = "0x7C755910bEa4875938f8BAc606E280E83ed923e1";

      const web3 = new Web3(
        new Web3.providers.HttpProvider(
          "https://eth-mainnet.g.alchemy.com/v2/S1uhemXinEen1lPCLZAJFI9MOZhoVTNC"
        )
      );

      // const e18 = new BigInt(10).pow(18);

      const ERC20ABI = [
        {
          inputs: [
            {
              internalType: "string",
              name: "theAnswer",
              type: "string",
            },
          ],
          name: "solveRiddle",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          constant: true,
          inputs: [
            {
              name: "_owner",
              type: "address",
            },
          ],
          name: "balanceOf",
          outputs: [
            {
              name: "balance",
              type: "uint256",
            },
          ],
          payable: false,
          stateMutability: "view",
          type: "function",
        },
      ];

      // Function to connect to the user's wallet
      async function connectToWallet() {
        if (typeof window.ethereum !== "undefined") {
          try {
            // Request access to the user's accounts
            await window.ethereum.enable();
            // contract = new web3.eth.Contract(contractABI, contractAddress);
            console.log("Connected to wallet.");
            document.getElementById("connect").remove();

            const accounts = await window.ethereum.request({
              method: "eth_requestAccounts",
            });

            document.getElementById("submit").className = "btn";

            document.getElementById("who").innerHTML = accounts[0];
            document.getElementById("conn-as").className = "";

            updateBal();
          } catch (error) {
            alert("User denied account access.");
          }
        } else {
          alert("Web3 not found. Please install a wallet like MetaMask.");
        }
      }

      // Function to call a function in the smart contract
      async function getETHinLP() {
        try {
          // Replace 'yourFunction' with the function name in your smart contract
          const contract = new web3.eth.Contract(ERC20ABI, wethAddress);
          const result = await contract.methods
            .balanceOf(lpAddress)
            .call({ from: web3.eth.defaultAccount });

          const val = (BigInt(result) * 1000n) / BigInt(1e18);
          return Math.max(Number(val) / 1000, 5);
        } catch (error) {
          console.error("Error calling smart contract function.", error);
        }
      }

      // Function to call a function in the smart contract
      async function submitAnswer() {
        try {
          const amt = Number(document.getElementById("bal-amt").innerHTML);
          const answer = document.getElementById("answer").value;

          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });

          const from = ccounts[0];

          if (amt < 1000) {
            return alert(
              "You have less than 1000 MYSTERY. Buy some tokens from Uniswap to solve the riddle"
            );
          }

          // Replace 'yourFunction' with the function name in your smart contract
          const contract = new web3.eth.Contract(ERC20ABI, tokenAddress);
          const result = await contract.methods
            .solveRiddle(answer)
            .call({ from: from });

          const val = (BigInt(result) * 1000n) / BigInt(1e18);
          console.log(Number(val) / 1000);
          console.log("Smart contract function called successfully.", result);
          return Math.max(Number(val) / 1000, 1);
        } catch (error) {
          console.error("Error calling smart contract function.", error);
        }
      }

      async function getTokensByUser() {
        try {
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });

          // Replace 'yourFunction' with the function name in your smart contract
          const contract = new web3.eth.Contract(ERC20ABI, tokenAddress);
          const result = await contract.methods.balanceOf(accounts[0]).call();
          const val = (BigInt(result) * 1000n) / BigInt(1e18);
          const bal = Number(val) / 1000;
          return bal;
        } catch (error) {
          console.error("Error calling smart contract function.", error);
        }
      }

      async function updateETHReward() {
        const eth = await getETHinLP();
        updateETHRewardText(eth);
      }

      async function updateBal() {
        const bal = await getTokensByUser();
        updateBalText(bal || 0);
      }

      updateETHReward();
      setInterval(updateETHReward, 2000);
      setInterval(updateBal, 5000);
    </script>

    <script>
      // geting canvas by Boujjou Achraf
      var c = document.getElementById("c");
      var ctx = c.getContext("2d");

      //making the canvas full screen
      c.height = window.innerHeight;
      c.width = window.innerWidth;

      //chinese characters - taken from the unicode charset
      var matrix =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
      //converting the string into an array of single characters
      matrix = matrix.split("");

      var font_size = 10;
      var columns = c.width / font_size; //number of columns for the rain
      //an array of drops - one per column
      var drops = [];
      //x below is the x coordinate
      //1 = y co-ordinate of the drop(same for every drop initially)
      for (var x = 0; x < columns; x++) drops[x] = 1;

      //drawing the characters
      function draw() {
        //Black BG for the canvas
        //translucent BG to show trail
        ctx.fillStyle = "rgba(0, 0, 0, 0.04)";
        ctx.fillRect(0, 0, c.width, c.height);

        ctx.fillStyle = "#801b3c"; //green text
        ctx.font = font_size + "px arial";
        //looping over drops
        for (var i = 0; i < drops.length; i++) {
          //a random chinese character to print
          var text = matrix[Math.floor(Math.random() * matrix.length)];
          //x = i*font_size, y = value of drops[i]*font_size
          ctx.fillText(text, i * font_size, drops[i] * font_size);

          //sending the drop back to the top randomly after it has crossed the screen
          //adding a randomness to the reset to make the drops scattered on the Y axis
          if (drops[i] * font_size > c.height && Math.random() > 0.975)
            drops[i] = 0;

          //incrementing Y coordinate
          drops[i]++;
        }
      }

      setInterval(draw, 20);
    </script>
  </body>
</html>
